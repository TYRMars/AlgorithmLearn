# 03-01-02
## 算法分析框架

* 首先必须指出，有两种算法效率，时间效率和空间效率。
* 时间效率也称为时间复杂度，指出正在讨论的算法运行的有多快
* 空间效率也称为空间复杂度，关心算法需要的额外空间

## 目录
* [01-01](https://github.com/TYRMars/AlgorithmLearn/tree/master/Algorithms/03-01-02#01-01)`输入规模度量`
* [01-02](https://github.com/TYRMars/AlgorithmLearn/tree/master/Algorithms/03-01-02#01-02)`运行时间的度量单位`
* [01-03](https://github.com/TYRMars/AlgorithmLearn/tree/master/Algorithms/03-01-02#01-03)`增长次数`

## 01-01
### 输入规模度量

* 几乎所有的算法，对于规模更大的输入都需要运行更长时间。
* 例如：需要更多时间对更长的数组排序，更大的矩阵相乘也需要华为更多时间
* 在研究算法效率时，把它作为一个以算法输入规模n为参数的函数是非常合乎逻辑的。
* 对于排序、查找、寻找列表的最小元素以及其他大多数和列表有关的问题来说，这个参数就是列表的长度。就一个对n次多项式p(x)=a<sub>n</sub>x<sup>n</sup>+...+a<sub>0</sub>求值的问题来说，这个参数是多项式的次数，或者是它系数的个数，系数的个数比次数大1。
* 速度越快的存储，其容量越小，反之也成立。算法的具体实现必须得考虑这些问题

## 01-02
### 运行时间的度量单位

*

## 01-03
### 增长次数

* 对算法分析具有重要意义的函数值

| n  | log<sub>2</sub>n  | n  | nlog<sub>2</sub>n | n<sup>2</sup>    | n<sup>3</sup>      | 2<sup>n</sup>     | n!    |
| :------------- | :------------- | :------------- | :------------- | :------------- | :------------- | :------------- | :------------- |
| 10       | 3.3       | 10<sup>1</sup>    | 3.3*10<sup>1</sup>    | 10<sup>2</sup>       | 10<sup>3</sup>     | 10<sup>3</sup>    | 3.6*10<sup>6</sup>   |
| 10<sup>2</sup>   | 6.6  | 10<sup>2</sup>  |  6.6*10<sup>2</sup> | 10<sup>4</sup>  | 10<sup>6</sup>  | 1.3*10<sup>30</sup>  | 9.3*10<sup>157</sup>  |
| 10<sup>3</sup>   | 10  | 10<sup>3</sup>  | 1.0*10<sup>4</sup>  | 10<sup>6</sup>  | 10<sup>9</sup>  |   |   |
| 10<sup>4</sup>   | 13  | 10<sup>4</sup>  | 1.3*10<sup>5</sup>  | 10<sup>8</sup>  | 10<sup>12</sup>  |   |   |
| 10<sup>5</sup>   | 17  | 10<sup>5</sup>  | 1.7*10<sup>6</sup>  | 10<sup>10</sup>  | 10<sup>15</sup>  |   |   |
| 10<sup>6</sup>   | 20  | 10<sup>6</sup>  | 2.0*10<sup>7</sup>  | 10<sup>12</sup>  | 10<sup>18</sup>  |   |   |

* 数字的数量级对于算法的分析具有深远意义。这些函数中增长最慢的是对数函数。
* 实际上，它的增长是如此之慢，以至于我们可以认为；如果一个程序的算法具有对数级的基本操作次数，该程序对于任何实际规模的输入几乎都会在瞬间完成
  - log<sub>2</sub>*n* = log<sub>a</sub>*b* * log<sub>b</sub>*n*
